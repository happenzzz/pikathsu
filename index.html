<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Pikachu Balloon Volleyball — Head Pop Defense</title>
<style>
  :root{
    --bg:#e6f3ff; --court:#f3d39a; --net:#ffffff; --text:#111827;
    --pika:#ffd235; --cheek:#ff5e5e; --ear:#2b2b2b;
    --ui:#ffffffcc; --accent:#2563eb; --secondary:#475569;
  }
  html,body{margin:0;padding:0;height:100%;background:var(--bg)}
  body{display:flex;align-items:center;flex-direction:column;font-family:system-ui,Apple SD Gothic Neo,Pretendard,sans-serif;color:var(--text)}
  #wrap{width:min(1000px,96vw)}
  #hud{display:flex;flex-direction:column;gap:.5rem;background:var(--ui);backdrop-filter:blur(6px);
       padding:.6rem .75rem;border-radius:12px;margin:.6rem 0 .2rem 0}
  .row{display:flex;align-items:center;justify-content:space-between;gap:.6rem;flex-wrap:wrap}
  .scoreboard{display:flex;align-items:center;gap:.8rem;white-space:nowrap}
  .score{font-weight:900;font-size:1.7rem}
  .goal-pill{display:inline-flex;align-items:center;gap:.35rem;background:#0f172acc;color:#fff;border-radius:999px;padding:.25rem .6rem;font-weight:700;white-space:nowrap}
  .controls{display:flex;flex-wrap:wrap;gap:.4rem}
  button{border:none;padding:.5rem .8rem;border-radius:10px;background:var(--accent);color:#fff;font-weight:800;cursor:pointer}
  button.secondary{background:var(--secondary)}
  select,input[type=file],input[type=range],input[type=text]{font-size:.92rem}
  .group{display:flex;align-items:center;gap:.35rem;background:#eef2ff;border-radius:10px;padding:.25rem .45rem}
  .small{font-size:.82rem;opacity:.9}
  #canvas{display:block;width:100%;height:auto;border-radius:14px;box-shadow:0 8px 24px #00000033}
  #help{font-size:.92rem;line-height:1.35;margin:.5rem 0 .8rem;background:#ffffffb0;border-radius:12px;padding:.6rem .8rem}
  kbd{background:#111;color:#fff;border-radius:6px;padding:.1rem .35rem;font-weight:700}
  input[type=file]{background:#fff;border-radius:8px;padding:.35rem}
  .name{border:1px solid #c7d2fe;background:#fff;border-radius:8px;padding:.25rem .5rem;width:9.5rem}
  .name::placeholder{color:#94a3b8}
</style>
</head>
<body>
<div id="wrap">
  <div id="hud">
    <div class="row">
      <div class="scoreboard">
        <div class="score"><span id="nm1">P1</span> <span id="s1">0</span> : <span id="s2">0</span> <span id="nm2">P2</span></div>
        <span class="goal-pill">목표 <span id="goal">15</span>점</span>
        <span class="goal-pill">세트 <span id="set1">0</span> : <span id="set2">0</span></span>
      </div>
      <div class="controls">
        <button id="btnStart">시작/일시정지</button>
        <button id="btnRound" class="secondary">라운드 리셋</button>
        <button id="btnNewGame" class="secondary">새 게임(점수만 0:0)</button>
        <button id="btnResetSets" class="secondary">세트 리셋</button>
        <button id="btnMode" class="secondary">모드: 2인용</button>
        <label class="group small">난이도
          <select id="difficulty">
            <option value="easy">쉬움</option>
            <option value="normal" selected>보통</option>
            <option value="hard">어려움</option>
          </select>
        </label>
      </div>
    </div>
    <div class="row">
      <div class="controls">
        <div class="group">
          <label class="small">P1 이름</label><input id="name1" type="text" class="name" placeholder="예: 피카1" maxlength="12">
        </div>
        <div class="group">
          <label class="small">P2 이름</label><input id="name2" type="text" class="name" placeholder="예: 피카2" maxlength="12">
        </div>
        <div class="group">
          <label class="small">P1 PNG</label><input id="p1png" type="file" accept="image/*">
          <label class="small">크기</label><input id="p1scale" type="range" min="0.6" max="1.8" step="0.05" value="1">
        </div>
        <div class="group">
          <label class="small">P2 PNG</label><input id="p2png" type="file" accept="image/*">
          <label class="small">크기</label><input id="p2scale" type="range" min="0.6" max="1.8" step="0.05" value="1">
        </div>
      </div>
    </div>
  </div>

  <canvas id="canvas" width="960" height="540" aria-label="Pikachu Balloon Volleyball"></canvas>

  <div id="help">
    <b>조작</b> — P1: <kbd>A</kbd>/<kbd>D</kbd> 이동, <kbd>W</kbd> 점프, <kbd>F</kbd> 서브·스파이크 |
    P2: <kbd>←</kbd>/<kbd>→</kbd> 이동, <kbd>↑</kbd> 점프, <kbd>/</kbd> 서브·스파이크<br>
    <b>규칙</b> — 풍선처럼 천천히 뜨고, <u>머리(윗부분)에 맞으면 크게 ‘뽕’</u>. 스파이크일 때만 고속 모드(≈1.1초).
  </div>
</div>

<script>
(() => {
  const css = getComputedStyle(document.documentElement);
  const COLOR = {
    court: css.getPropertyValue('--court').trim() || '#f3d39a',
    net:   css.getPropertyValue('--net').trim()   || '#ffffff',
    pika:  css.getPropertyValue('--pika').trim()  || '#ffd235',
    cheek: css.getPropertyValue('--cheek').trim() || '#ff5e5e',
    ear:   css.getPropertyValue('--ear').trim()   || '#2b2b2b',
  };

  // --- 풍선 물리 & 스파이크 고속 모드 ---
  const PHYS = {
    balloon: { G: 900, AIR: 0.980, MAX: 700 },
    fast:    { G: 900, AIR: 0.995, MAX: 1100, DURATION: 1.1 }
  };

  const W = 960, H = 540;
  const BOUNCE = 0.82;
  const FLOOR_Y = H - 32;
  const NET = { x: W/2 - 6, y: FLOOR_Y - 160, w: 12, h: 160 };
  const GOAL = 15;

  const P = {
    w: 72, h: 82,
    move: 560, maxVx: 420, jump: 820, airCtrl: 0.5,
    hitBoost: 680,
    serveOffset: {x: 30, y: -100},
  };

  // 수비 팝업 계수 (판정 확대)
  const POP_UP    = 720;   // 몸통 ‘뽕’ 기본값 조금 ↑
  const HEAD_ZONE = 0.65;  // 윗부분 비율(커짐: 판정 넓어짐)
  const HEAD_POP  = 1050;  // 머리 맞으면 크게
  const HEAD_SIDE = 160;   // 머리 수비 시 상대 코트로 미는 힘
  const SERVE_SPEED = 340;

  const cv = document.getElementById('canvas');
  const ctx = cv.getContext('2d'); ctx.imageSmoothingEnabled = false;

  const s1El = document.getElementById('s1');
  const s2El = document.getElementById('s2');
  const nm1El = document.getElementById('nm1');
  const nm2El = document.getElementById('nm2');
  const set1El = document.getElementById('set1');
  const set2El = document.getElementById('set2');
  document.getElementById('goal').textContent = GOAL;

  const name1Input = document.getElementById('name1');
  const name2Input = document.getElementById('name2');

  const keys = new Set();
  let last = performance.now();
  let running = true;

  const state = {
    score1:0, score2:0,
    set1:0, set2:0,
    server:1, serving:true, msg:'F 또는 / 로 서브!',
    modeAI:false, difficulty:'normal', gameOver:false,
    names:{1:'P1',2:'P2'},
    msgTimer:0
  };

  // 이름 로드/바인딩
  function loadNames(){
    const n1 = localStorage.getItem('pika_name1') || 'P1';
    const n2 = localStorage.getItem('pika_name2') || 'P2';
    state.names[1] = n1; state.names[2] = n2;
    name1Input.value = n1; name2Input.value = n2;
    nm1El.textContent = n1; nm2El.textContent = n2;
  }
  loadNames();

  name1Input.addEventListener('input', ()=>{
    const v = name1Input.value.trim() || 'P1';
    state.names[1]=v; nm1El.textContent=v; localStorage.setItem('pika_name1',v);
  });
  name2Input.addEventListener('input', ()=>{
    const v = name2Input.value.trim() || 'P2';
    state.names[2]=v; nm2El.textContent=v; localStorage.setItem('pika_name2',v);
  });

  const p1 = makePlayer(120, FLOOR_Y - P.h);
  const p2 = makePlayer(W - 120 - P.w, FLOOR_Y - P.h);
  const ball = makeBall(); ball.fastTimer = 0;

  const sprites = { p1:{img:null,scale:1}, p2:{img:null,scale:1} };

  // --- 유틸 ---
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function len(x,y){ return Math.hypot(x,y); }
  function norm(x,y){ const l = Math.hypot(x,y)||1; return {x:x/l,y:y/l}; }
  function rectCircleOverlap(rx,ry,rw,rh,cx,cy,cr){
    const nx = clamp(cx, rx, rx+rw), ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny, d2 = dx*dx+dy*dy;
    return d2 <= cr*cr ? {dx,dy,dist:Math.sqrt(d2)||0.0001} : null;
  }
  function aabbOverlap(ax,ay,aw,ah,bx,by,bw,bh){
    return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;
  }
  function makePlayer(x,y){
    return { x,y, w:P.w, h:P.h, vx:0, vy:0, onGround:false,
      leftBound: x < W/2 ? 0 : W/2 + NET.w, rightBound: x < W/2 ? W/2 - NET.w : W,
      wantHit:false, lastHitTime:-999 };
  }
  function makeBall(){ return { x: W/4, y: 120, vx: 260, vy: -140, r: 16, servingTo: 1 }; }
  function syncScoreUI(){ s1El.textContent = state.score1; s2El.textContent = state.score2; }
  function syncSetUI(){ set1El.textContent = state.set1; set2El.textContent = state.set2; }
  function hardReset(){ state.score1=0; state.score2=0; state.gameOver=false; state.server=Math.random()<.5?1:2; newRound(state.server); }
  function resetSets(){ state.set1=0; state.set2=0; syncSetUI(); }
  function newRound(server){
    state.serving=true; state.gameOver=false; state.msgTimer=0;
    state.msg = (server===1?`${state.names[1]}`:`${state.names[2]}`) + ' 서브: (P1:<F> / P2:</>)';
    Object.assign(p1,{x:120,y:FLOOR_Y-P.h,vx:0,vy:0,onGround:true});
    Object.assign(p2,{x:W-120-P.w,y:FLOOR_Y-P.h,vx:0,vy:0,onGround:true});
    ball.x = server===1 ? p1.x + P.serveOffset.x : p2.x + P.serveOffset.x + P.w - 2*ball.r;
    ball.y = (server===1 ? p1.y : p2.y) + P.serveOffset.y;
    ball.vx=0; ball.vy=0; ball.servingTo=server; ball.fastTimer=0;
    syncScoreUI();
    if(state.modeAI && server===2){ setTimeout(()=>{ if(state.serving) p2.wantHit=true; },520); setTimeout(()=>{ p2.wantHit=false; },760); }
  }

  // --- 입력/UI ---
  addEventListener('keydown', e=>{
    keys.add(e.key);
    if(e.key==='f'||e.key==='F') p1.wantHit=true;
    if(!state.modeAI && e.key==='/') p2.wantHit=true;
    if(e.key==='p'||e.key==='P') running=!running;
  });
  addEventListener('keyup', e=>{
    keys.delete(e.key);
    if(e.key==='f'||e.key==='F') p1.wantHit=false;
    if(!state.modeAI && e.key==='/') p2.wantHit=false;
  });
  document.getElementById('btnStart').onclick = ()=> running=!running;
  document.getElementById('btnRound').onclick = ()=> { if(!state.gameOver) newRound(state.server); };
  document.getElementById('btnNewGame').onclick = ()=> { state.score1=0; state.score2=0; syncScoreUI(); newRound(state.server); };
  document.getElementById('btnResetSets').onclick = ()=> resetSets();
  const btnMode = document.getElementById('btnMode');
  btnMode.onclick = ()=>{ state.modeAI=!state.modeAI; btnMode.textContent = state.modeAI?'모드: 1인용 AI':'모드: 2인용'; newRound(1); };
  const diffSel = document.getElementById('difficulty'); diffSel.onchange = ()=> state.difficulty = diffSel.value;

  document.getElementById('p1png').addEventListener('change', e=>loadPNG('p1',e));
  document.getElementById('p2png').addEventListener('change', e=>loadPNG('p2',e));
  document.getElementById('p1scale').addEventListener('input', e=>sprites.p1.scale=+e.target.value);
  document.getElementById('p2scale').addEventListener('input', e=>sprites.p2.scale=+e.target.value);
  function loadPNG(which,e){ const f=e.target.files?.[0]; if(!f)return; const u=URL.createObjectURL(f); const img=new Image(); img.onload=()=>{sprites[which].img=img; URL.revokeObjectURL(u);}; img.src=u; }

  // --- 루프 ---
  function frame(t){ const dt=Math.min(1/30,(t-last)/1000); last=t; if(running) update(dt); draw(); requestAnimationFrame(frame); }
  requestAnimationFrame(frame);

  // --- 업데이트 ---
  function update(dt){
    if(state.gameOver) return;

    if(state.msgTimer>0){ state.msgTimer -= dt; if(state.msgTimer<=0) state.msg=''; }

    // 서브
    if(state.serving){
      const srv = ball.servingTo===1? p1 : p2;
      ball.x = srv.x + (srv===p1 ? P.serveOffset.x+ball.r : P.w - P.serveOffset.x - ball.r);
      ball.y = srv.y + P.serveOffset.y;
      const hit = (srv===p1 && p1.wantHit) || (srv===p2 && (state.modeAI ? true : p2.wantHit));
      if(hit){
        const dir = srv===p1 ? {x: 1, y: -0.4} : {x: -1, y: -0.4};
        const n = norm(dir.x, dir.y);
        ball.vx = n.x * SERVE_SPEED; ball.vy = n.y * SERVE_SPEED;
        state.serving=false; state.msg='';
      }
    }

    // 입력/AI
    stepPlayer(p1, dt, {left:['a','A'], right:['d','D'], jump:['w','W']});
    if(!state.modeAI) stepPlayer(p2, dt, {left:['ArrowLeft'], right:['ArrowRight'], jump:['ArrowUp']});
    else aiControl(p2, dt);

    if(!state.serving) stepBall(dt);

    handleBallPlayer(ball, p1);
    handleBallPlayer(ball, p2);
    handleBallNet(ball);

    if(ball.y + ball.r >= FLOOR_Y){
      const leftSide = ball.x < W/2;
      pointTo(leftSide ? 2 : 1);
    }
  }

  function currentPhys(){ return ball.fastTimer>0 ? PHYS.fast : PHYS.balloon; }

  function stepPlayer(p,dt,keysMap){
    const wantL=keysMap.left?.some(k=>keys.has(k))??false;
    const wantR=keysMap.right?.some(k=>keys.has(k))??false;
    const wantJ=keysMap.jump?.some(k=>keys.has(k))??false;

    const accel = p.onGround ? P.move : P.move*P.airCtrl;
    if(wantL) p.vx -= accel*dt;
    if(wantR) p.vx += accel*dt;
    if(!(wantL||wantR) && p.onGround){
      const f=1900*dt; if(Math.abs(p.vx)<=f) p.vx=0; else p.vx -= f*Math.sign(p.vx);
    }
    p.vx = clamp(p.vx, -P.maxVx, P.maxVx);

    if(wantJ && p.onGround){ p.vy = -P.jump; p.onGround=false; }
    p.vy += currentPhys().G*dt;

    p.x += p.vx*dt; p.y += p.vy*dt;

    if(p.x < p.leftBound){ p.x=p.leftBound; p.vx=0; }
    if(p.x + p.w > p.rightBound){ p.x=p.rightBound - p.w; p.vx=0; }

    if(p.y + p.h >= FLOOR_Y){ p.y=FLOOR_Y-p.h; p.vy=0; p.onGround=true; } else p.onGround=false;

    const nRect = NET;
    if(aabbOverlap(p.x,p.y,p.w,p.h, nRect.x,nRect.y,nRect.w,nRect.h)){
      if(p.x + p.w/2 < W/2) p.x = nRect.x - p.w; else p.x = nRect.x + nRect.w;
      p.vx = 0;
    }
  }

  function stepBall(dt){
    const phys = currentPhys();
    if(ball.fastTimer>0) ball.fastTimer -= dt;

    ball.vy += phys.G*dt;
    ball.x += ball.vx*dt; ball.y += ball.vy*dt;

    const d = Math.pow(phys.AIR, dt*60);
    ball.vx *= d; ball.vy *= d;

    if(ball.x - ball.r < 0){ ball.x = ball.r; ball.vx = -ball.vx*BOUNCE; }
    if(ball.x + ball.r > W){ ball.x = W - ball.r; ball.vx = -ball.vx*BOUNCE; }
    if(ball.y - ball.r < 0){ ball.y = ball.r; ball.vy = -ball.vy*BOUNCE; }

    const sp = len(ball.vx, ball.vy), cap = phys.MAX;
    if(sp>cap){ const k = cap/sp; ball.vx*=k; ball.vy*=k; }
  }

  function handleBallPlayer(b,p){
    const hit = rectCircleOverlap(p.x,p.y,p.w,p.h, b.x,b.y,b.r); if(!hit) return;

    // 침투 해소
    const l = Math.hypot(hit.dx, hit.dy)||0.0001; const nx = hit.dx/l, ny = hit.dy/l;
    const overlap = b.r - hit.dist; b.x += nx*overlap; b.y += ny*overlap;

    // 기본 반사(풍선 느낌)
    const vn = b.vx*nx + b.vy*ny;
    const vtX = b.vx - vn*nx, vtY = b.vy - vn*ny;
    const newVn = -vn * 0.75;
    b.vx = vtX + newVn*nx + p.vx*0.20;
    b.vy = vtY + newVn*ny + p.vy*0.10;

    const now = performance.now();
    const pressing = (p===p1) ? p1.wantHit : p2.wantHit;

    // 예: 살짝 떠오르는 중이라도 수비 팝업 허용(완화)
    const comingDown = b.vy > -180;

    if(!pressing && comingDown){
      // 헤드 존(윗부분)에 맞으면 크게 ‘뽕’ — 세로/가로 판정 크게
      const headLine = p.y + p.h*HEAD_ZONE; // 이 선보다 위면 '머리/윗부분'
      const horizontalSlack = b.r * 1.5;     // 좌우 여유폭 ↑
      const inHead = (b.y <= headLine) &&
                     (b.x >= p.x - horizontalSlack) &&
                     (b.x <= p.x + p.w + horizontalSlack);

      if(inHead){
        b.vy -= HEAD_POP;
        b.vx += (p===p1 ? +HEAD_SIDE : -HEAD_SIDE);
      }else{
        b.vy -= POP_UP; // 몸통은 보통 ‘뽕’
      }
      // 수비는 고속 모드로 바꾸지 않음
    }else if(pressing && now - p.lastHitTime > 90){
      // 스파이크: 고속 모드 + 아래로 강하게
      let ax = (p===p1)? +1 : -1;
      let ay = +0.60;
      const upHeld = (p===p1) ? (keys.has('w')||keys.has('W')) :
                               (state.modeAI ? false : keys.has('ArrowUp'));
      if(upHeld) ay -= 0.55;
      const a = norm(ax, ay);
      b.vx += a.x * P.hitBoost;
      b.vy += a.y * P.hitBoost;
      p.lastHitTime = now;
      ball.fastTimer = PHYS.fast.DURATION;
    }
  }

  function handleBallNet(b){
    const hit = rectCircleOverlap(NET.x,NET.y,NET.w,NET.h, b.x,b.y,b.r); if(!hit) return;
    const l = Math.hypot(hit.dx, hit.dy)||0.0001; const nx = hit.dx/l, ny = hit.dy/l;
    const overlap = b.r - hit.dist; b.x += nx*overlap; b.y += ny*overlap;
    const vn = b.vx*nx + b.vy*ny;
    const vtX = b.vx - vn*nx, vtY = b.vy - vn*ny;
    const newVn = -vn * 0.9; b.vx = vtX + newVn*nx; b.vy = vtY + newVn*ny;
  }

  function pointTo(who){
    if(who===1) state.score1++; else state.score2++;
    syncScoreUI();
    if(state.score1>=GOAL || state.score2>=GOAL){
      // 세트 획득 처리
      if(state.score1>state.score2){ state.set1++; state.server = 1; flashMsg(`${state.names[1]} 1세트 획득!`); }
      else                         { state.set2++; state.server = 2; flashMsg(`${state.names[2]} 1세트 획득!`); }
      syncSetUI();
      state.score1=0; state.score2=0; syncScoreUI();
      newRound(state.server); // 다음 세트 바로 시작
      return;
    }
    state.server = who; newRound(state.server);
  }

  function flashMsg(text, sec=1.6){
    state.msg = text; state.msgTimer = sec;
  }

  // --- AI(풍선물리 반영) ---
  function aiControl(p, dt){
    const DIFF = {
      easy:   { react:.45, moveK:.95, anticipate:12, jumpAgg:.9,  blockSense:.25, hitProb:.7 },
      normal: { react:.60, moveK:1.05, anticipate:18, jumpAgg:1.1, blockSense:.45, hitProb:.9 },
      hard:   { react:.78, moveK:1.15, anticipate:22, jumpAgg:1.2, blockSense:.60, hitProb:1.0 },
    }[state.difficulty];

    const pred = predictLanding(3.0);
    let targetX = clamp(pred.x + DIFF.anticipate, W/2 + NET.w + 16, W - 20);
    targetX = lerp(p.x + p.w/2, targetX, DIFF.react);

    let wantL=false,wantR=false,wantJ=false;
    if(targetX < p.x + p.w/2 - 6) wantL=true; else if(targetX > p.x + p.w/2 + 6) wantR=true;

    const nearNet = Math.abs(ball.x - (W/2 + 6)) < 28 && ball.vy > -50 && ball.x > W/2;
    if(nearNet && ball.y < p.y - 6 && Math.random() < DIFF.blockSense*dt){
      if(p.x + p.w/2 > W/2 + 18) wantL=true;
      wantJ = p.onGround;
    }
    if(ball.vy > -60 && ball.y < p.y - 10 && Math.abs(ball.x - (p.x+p.w/2)) < (32 + 90*DIFF.jumpAgg)){
      if(p.onGround) wantJ = true;
    }

    const close = rectCircleOverlap(p.x,p.y,p.w,p.h, ball.x,ball.y, ball.r+10);
    p2.wantHit = !!(close && Math.random() < DIFF.hitProb);

    const fake = { left: wantL?['L']:null, right: wantR?['R']:null, jump: wantJ?['J']:null };
    const om=P.move, ox=P.maxVx; P.move=om*DIFF.moveK; P.maxVx=ox*DIFF.moveK;
    stepPlayer(p, dt, fake);
    P.move=om; P.maxVx=ox;
  }

  function predictLanding(maxTime){
    const phys = PHYS.balloon;
    let x=ball.x, y=ball.y, vx=ball.vx, vy=ball.vy;
    const dt=1/120, steps=Math.floor(maxTime/dt);
    for(let i=0;i<steps;i++){
      vy += phys.G*dt; x += vx*dt; y += vy*dt;
      const d=Math.pow(phys.AIR, dt*60); vx*=d; vy*=d;
      if(x - ball.r < 0){ x=ball.r; vx=-vx*BOUNCE; }
      if(x + ball.r > W){ x=W-ball.r; vx=-vx*BOUNCE; }
      if(y - ball.r < 0){ y=ball.r; vy=-vy*BOUNCE; }
      const hit = rectCircleOverlap(NET.x,NET.y,NET.w,NET.h, x,y,ball.r);
      if(hit){
        const l=Math.hypot(hit.dx,hit.dy)||0.0001, nx=hit.dx/l, ny=hit.dy/l;
        const vn=vx*nx+vy*ny, vtX=vx-vn*nx, vtY=vy-vn*ny; vx=vtX + (-vn*0.9)*nx; vy=vtY + (-vn*0.9)*ny;
        x += nx*(ball.r - hit.dist); y += ny*(ball.r - hit.dist);
      }
      if(y + ball.r >= FLOOR_Y) return { x, t:i*dt };
    }
    return { x, t:maxTime };
  }
  function lerp(a,b,t){ return a + (b-a)*t; }

  // --- 렌더링 ---
  function drawCourt(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = COLOR.court; ctx.fillRect(0, FLOOR_Y, W, H-FLOOR_Y);
    ctx.fillStyle = COLOR.net;   ctx.fillRect(NET.x, NET.y, NET.w, NET.h);
    ctx.globalAlpha = .45; for(let y=NET.y+8; y<NET.y+NET.h; y+=12){ ctx.fillRect(NET.x-36, y, NET.w+72, 2); } ctx.globalAlpha = 1;
    ctx.globalAlpha = .25; ctx.fillRect(W/2-1, FLOOR_Y-4, 2, 4); ctx.globalAlpha = 1;
  }
  function drawPlayer(p,facing,which){
    const spr=sprites[which], scale=spr.scale||1;
    if(spr.img){
      const w=P.w*scale,h=P.h*scale,cx=p.x+(P.w-w)/2,cy=p.y+(P.h-h);
      ctx.save(); ctx.imageSmoothingEnabled=false;
      if(facing<0){ ctx.translate(cx+w/2,cy+h/2); ctx.scale(-1,1); ctx.drawImage(spr.img,-w/2,-h/2,w,h); }
      else ctx.drawImage(spr.img,cx,cy,w,h);
      ctx.restore();
    }else drawPikachu(p,facing);
  }
  function drawPikachu(p,facing){
    const x=p.x,y=p.y,w=P.w,h=P.h; ctx.save();
    ctx.fillStyle=COLOR.pika; roundRect(x+8,y+12,w-16,h-20,14,true);
    ctx.fillStyle=COLOR.pika; const eW=14,eH=26; ctx.fillRect(x+16,y-4,eW,eH); ctx.fillRect(x+w-16-eW,y-4,eW,eH);
    ctx.fillStyle=COLOR.ear; ctx.fillRect(x+16,y-4,eW,10); ctx.fillRect(x+w-16-eW,y-4,eW,10);
    ctx.fillStyle='#000'; const ey=y+36, ex1=facing>0?x+w-30:x+20, ex2=facing>0?x+w-48:x+38;
    ctx.beginPath(); ctx.arc(ex1,ey,4,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(ex2,ey,4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=COLOR.cheek; const cy=y+52, cx1=facing>0?x+w-22:x+22, cx2=facing>0?x+w-58:x+58;
    ctx.beginPath(); ctx.arc(cx1,cy,6,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx2,cy,6,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=COLOR.pika; const tb=facing>0?x+4:x+w-4, s=facing>0?-1:1;
    ctx.beginPath(); ctx.moveTo(tb,y+40);
    ctx.lineTo(tb+18*s,y+28); ctx.lineTo(tb-2*s,y+16); ctx.lineTo(tb+24*s,y+0); ctx.lineTo(tb+6*s,y-10);
    ctx.lineTo(tb+30*s,y-26); ctx.lineTo(tb+10*s,y-18); ctx.lineTo(tb+28*s,y-2); ctx.lineTo(tb+8*s,y+12);
    ctx.closePath(); ctx.fill(); ctx.restore();
  }
  function roundRect(x,y,w,h,r,fill){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); if(fill) ctx.fill(); else ctx.stroke(); }
  function drawBall(b){
    const g=ctx.createRadialGradient(b.x-4,b.y-6,4,b.x,b.y,20); g.addColorStop(0,'#fff'); g.addColorStop(1,'#fef08a');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#d4a373'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(b.x,b.y,b.r*0.75,0,Math.PI*2); ctx.stroke();
  }
  function draw(){
    drawCourt(); drawPlayer(p1,+1,'p1'); drawPlayer(p2,-1,'p2'); drawBall(ball);
    if(state.msg){ ctx.save(); ctx.font='bold 22px system-ui,sans-serif'; ctx.fillStyle='#00000099'; ctx.textAlign='center'; ctx.fillText(state.msg,W/2,40); ctx.restore(); }
    if(!running || state.gameOver){
      ctx.save(); ctx.fillStyle='#00000066'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff';
      ctx.font='bold 32px system-ui,sans-serif'; ctx.textAlign='center';
      ctx.fillText(state.gameOver ? state.msg : '일시정지 (버튼 또는 P)', W/2, H/2); ctx.restore();
    }
  }

  hardReset();
})();
</script>
</body>
</html>
